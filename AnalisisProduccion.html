<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis de Producci√≥n | CapaSuite</title>
    <link rel="icon" type="image/png" href="Imagen/Icono_CapaSuite.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="Imagen/Icono_CapaSuite.png">
    <script src="js/chart.js"></script>
    <script src="js/storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="js/firebase-auth.js"></script>

    <style>
        :root {
            --primary: #4f46e5;
            --primary-dark: #3730a3;
            --bg-body: #f8fafc;
            --bg-surface: #ffffff;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --radius: 12px;
            --success: #10b981;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 15px;
            font-size: 13px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            width: 98%;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: var(--bg-surface);
            padding: 20px 30px;
            border-radius: var(--radius);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .title h1 {
            font-size: 1.5rem;
            margin: 0;
            color: var(--primary-dark);
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 10px 15px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            position: relative;
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-bottom: 24px;
        }

        .kpi-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 2px;
            line-height: 1.1;
        }

        .kpi-value {
            font-size: 1.15rem;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .kpi-trend {
            font-size: 0.7rem;
            margin-top: 3px;
        }

        .trend-up {
            color: var(--success);
        }

        .trend-down {
            color: #ef4444;
        }

        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }

        .chart-card {
            display: flex;
            flex-direction: column;
            height: 400px;
        }

        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }

        .table-container {
            overflow: auto;
            max-height: 500px;
            border-radius: var(--radius);
            background: white;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            white-space: nowrap;
        }

        th,
        td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            text-align: right;
            font-size: 0.85rem;
        }

        th {
            background: #f1f5f9;
            color: var(--text-muted);
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        th:first-child,
        td:first-child {
            text-align: left;
            position: sticky;
            left: 0;
            z-index: 11;
            font-weight: 600;
            min-width: 250px;
            background: #ffffff;
        }

        th:first-child {
            top: 0;
            z-index: 12;
            background: #f1f5f9 !important;
        }

        .row-group td:first-child {
            background: #f8fafc !important;
        }

        .row-group {
            background: #f8fafc;
            font-weight: 700;
            color: var(--primary);
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .upload-area {
            background: var(--bg-surface);
            border: 2px dashed #cbd5e1;
            border-radius: 16px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
        }

        .loader {
            display: none;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* MODAL */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
        }

        .modal-header {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }

        /* TOP NAVIGATION */
        .top-nav {
            background: #1e293b;
            padding: 0 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 99999;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            height: 45px;
        }

        .nav-links {
            display: flex;
            gap: 25px;
            height: 100%;
            align-items: center;
        }

        .top-nav a {
            color: #94a3b8;
            text-decoration: none;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            height: 100%;
            border-bottom: 2px solid transparent;
        }

        .top-nav a:hover {
            color: #ffffff;
        }

        .top-nav a.active {
            color: #818cf8;
            border-bottom: 2px solid #818cf8;
        }

        .nav-user {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 0.75rem;
        }

        .nav-user .user-email {
            font-weight: 500;
            opacity: 0.9;
        }

        .nav-user .logout-btn {
            color: #ef4444;
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.7rem;
            font-weight: 700;
        }

        .nav-user .dot {
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
        }
    </style>
</head>

<body style="padding: 0;">
    <nav class="top-nav">
        <div class="nav-links">
            <a href="index.html">üè† Inicio</a>
            <a href="AnalisisProduccion.html" class="active">üìà Producci√≥n</a>
            <a href="AnalisisSegmentos.html">üë• Segmentos</a>
            <a href="AnalisisCompetencia.html">‚öñÔ∏è Competencia</a>
            <a href="AnalisisIA.html" style="color:#f59e0b; font-weight:800;">‚ú® CapaAI</a>
            <a href="AnalisisCalendario.html">üìÖ Calendario</a>
            <a href="CalculadoraPresupuesto.html">üí∞ Presupuesto</a>
            <a href="CargarDatos.html">‚öôÔ∏è Config</a>
        </div>
        <div class="nav-user">
            <span class="dot"></span>
            <span class="user-email" id="userEmailNav">Cargando...</span>
            <span class="logout-btn" onclick="auth.signOut()">Cerrar Sesi√≥n</span>
        </div>
    </nav>
    <div class="container" style="padding: 15px;">
        <header class="header">
            <div style="display: flex; align-items: center; gap: 20px;">
                <a href="index.html"><img src="Imagen/logo, CapaSuite.png" alt="CapaSuite" style="height: 50px;"></a>
                <img id="hotelLogo" src="Imagen/logo-guadiana.svg" alt="Logo Hotel" style="height: 45px;">
                <div class="title">
                    <h1 id="mainTitle">Revenue Assistant</h1>
                    <div style="display: flex; align-items: center; gap: 12px; margin-top: 2px;">
                        <p id="mainSubtitle" style="margin:0;">An√°lisis Pace y Producci√≥n Detallada</p>
                        <span id="updateBadge"
                            style="display:none; font-size: 0.75rem; background: #fee2e2; color: #b91c1c; padding: 3px 12px; border-radius: 20px; font-weight: 600; border: 1px solid #fecaca; white-space: nowrap;">üìÖ
                            Actualizado: --</span>
                    </div>
                </div>
            </div>
            <div style="display:flex; gap:12px; align-items:center;">
                <select id="yearSelector" onchange="updateView()"
                    style="padding:10px; border-radius:8px; border:1px solid #e2e8f0;"></select>
                <select id="monthSelector" onchange="updateView()"
                    style="padding:10px; border-radius:8px; border:1px solid #e2e8f0;"></select>
                <select id="hotelSelector" onchange="switchHotel(this.value)"
                    style="padding:10px; border-radius:8px; border:1px solid #e2e8f0; font-weight:600;">
                    <option value="Guadiana">Hotel Guadiana</option>
                    <option value="Cumbria">Hotel Cumbria</option>
                </select>
            </div>
        </header>

        <div id="no-data-section" class="upload-area" style="display:none;">
            <div style="font-size: 3rem; margin-bottom: 20px;">üõ°Ô∏è</div>
            <h2>No se han encontrado datos</h2>
            <p>Por favor, utiliza el m√≥dulo de <b>Carga de Datos</b> para importar tus informes.</p>
            <a href="CargarDatos.html" class="btn"
                style="display:inline-block; text-decoration:none; margin-top:20px;">Ir a Carga de Datos</a>
        </div>

        <div id="loader" class="loader"></div>

        <div id="dashboard" style="display:none; flex-direction:column; gap:24px;">
            <div class="kpi-grid">
                <div class="card" style="border-left: 4px solid var(--primary);">
                    <div class="kpi-label">Producci√≥n Total</div>
                    <div class="kpi-value" id="kpi-total">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-total">--</div>
                </div>
                <div class="card">
                    <div class="kpi-label">Prod. Habitaci√≥n</div>
                    <div class="kpi-value" id="kpi-prod-hab">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-prod-hab">--</div>
                </div>
                <div class="card">
                    <div class="kpi-label">Estancias (RN)</div>
                    <div class="kpi-value" id="kpi-rn">0</div>
                    <div class="kpi-trend" id="trend-rn">--</div>
                </div>
                <div class="card">
                    <div class="kpi-label">Total Pax</div>
                    <div class="kpi-value" id="kpi-pax">0</div>
                    <div class="kpi-trend" id="trend-pax">--</div>
                </div>
                <div class="card" style="background: #f0fdf4;">
                    <div class="kpi-label" style="color: #166534;">ADR (Precio Medio)</div>
                    <div class="kpi-value" id="kpi-adr" style="color: #166534;">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-adr">--</div>
                </div>
                <div class="card" style="background: #eff6ff;">
                    <div class="kpi-label" style="color: #1e40af;">RevPAC (Gasto Total/Pax)</div>
                    <div class="kpi-value" id="kpi-revpac" style="color: #1e40af;">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-revpac">--</div>
                </div>
                <div class="card">
                    <div class="kpi-label">Ocupaci√≥n</div>
                    <div class="kpi-value" id="kpi-occ">0 %</div>
                    <div class="kpi-trend" id="trend-occ">--</div>
                </div>
                <div class="card" style="background: #fffbeb;">
                    <div class="kpi-label" style="color: #92400e;">RevPAR (Ingreso/Room Disp)</div>
                    <div class="kpi-value" id="kpi-revpar" style="color: #92400e;">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-revpar">--</div>
                </div>
                <div class="card">
                    <div class="kpi-label">Gasto Comp. / Pax</div>
                    <div class="kpi-value" id="kpi-comppax">0 ‚Ç¨</div>
                    <div class="kpi-trend" id="trend-comppax">--</div>
                </div>
            </div>

            <div class="charts-row" style="grid-template-columns: 1.5fr 1fr 1fr;">
                <div class="card chart-card">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="kpi-label" style="margin-bottom: 0;">Evoluci√≥n Mensual Detallada</div>
                        <select id="chartMetricSelector" onchange="render()"
                            style="font-size: 0.75rem; padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border); background: #f8fafc; cursor: pointer;">
                            <option value="total">Producci√≥n Total</option>
                            <option value="hab">Solo Habitaciones</option>
                            <option value="adr">Precio Medio (ADR)</option>
                            <option value="occ">Ocupaci√≥n (%)</option>
                        </select>
                    </div>
                    <div class="chart-container" style="width:100%;"><canvas id="mainChart"></canvas></div>
                </div>
                <div class="card chart-card">
                    <div class="kpi-label">Pace Report: Gasto Complementario por Pax</div>
                    <div class="chart-container"><canvas id="paceChart"></canvas></div>
                </div>
                <div class="card chart-card">
                    <div class="kpi-label">Mix de Producci√≥n (%)</div>
                    <div class="chart-container"><canvas id="mixChart"></canvas></div>
                </div>
            </div>

            <div class="card" style="padding: 0;">
                <div
                    style="padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0;">Detalle de Producci√≥n por Categor√≠as Hoteleras</h3>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span id="lastUpdateDetail"
                            style="font-size: 0.8rem; color: var(--text-muted); background: #f1f5f9; padding: 4px 12px; border-radius: 20px; font-weight: 600;">Actualizado:
                            --</span>
                        <img id="hotelLogoDetail" src="Imagen/logo-guadiana.svg" alt="Logo Hotel"
                            style="height: 40px; border: 1px solid #e2e8f0; padding: 4px; border-radius: 6px; background: white;">
                    </div>
                </div>
                <div class="table-container">
                    <table id="dataTable">
                        <thead id="tableHead"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para Drill-down -->
    <div id="subMixModal" class="modal">
        <div class="modal-content">
            <span class="close-modal"
                onclick="document.getElementById('subMixModal').style.display='none'">&times;</span>
            <div class="modal-header">
                <h3 id="subMixTitle" style="color: var(--primary);">Distribuci√≥n Detallada</h3>
                <p id="subMixSubtitle" style="font-size: 0.8rem; color: var(--text-muted);">Desglose por conceptos del
                    grupo seleccionado</p>
            </div>
            <div style="height: 400px; position: relative;">
                <canvas id="subMixChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const MONTH_ORDER = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
        const SHORT_MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const HOTELS = { "Guadiana": { rooms: 108 }, "Cumbria": { rooms: 59 } };
        function fmtNum(n) { return new Intl.NumberFormat('es-ES', { maximumFractionDigits: 0 }).format(n); }
        function fmt(n) { return fmtNum(n) + " ‚Ç¨"; }

        const PRODUCTION_GROUPS = {
            "HABITACION": { name: "1. Habitaci√≥n", keys: ["HABITACI√ìN", "HABITACION", "ALOJAMIENTO", "ESTANCIA", "DUI", "DOBLE", "SUPERIOR", "SUITE", "CUADRUPLE", "TRIPLE", "FAMILIAR", "LATE CHECK OUT", "AMPLIACION", "CAMA SUPLETORIA", "REGARGO GDS", "HABITACI√ì"] },
            "DESAYUNOS": { name: "2. Desayunos", keys: ["DESAYUNO BUFFET", "DESAYUNO GRUPO", "DESAYUNO", "BUFFET"] },
            "RESTAURANTE": { name: "3. Restaurante", keys: ["RESTAURANTE", "CENA", "ALMUERZO", "CENA GRUPO", "ALMUERZO GRUPO", "CATERING", "RESTAURANTE CATERING"] },
            "OFICINAS": { name: "9. Alquileres", keys: ["ALQUILER RETENCIONES", "OFICINA", "RETENCIONES", "FIANZA", "DOMICILIACION EMPRESAS", "LIMPIEZA"] },
            "EVENTOS": { name: "4. Eventos", keys: ["COFFEE BREAK", "SALONES/ALQUILER", "AUDIOVISUALES", "SALON", "ALQUILER", "EVENTO"] },
            "CAFETERIA": { name: "5. Cafeter√≠a", keys: ["CAFETER√çA", "CAFETERIA", "BAR"] },
            "MINIBAR": { name: "6. Minibar", keys: ["MINIBAR"] },
            "SPA": { name: "7. Spa", keys: ["SPA", "BALNEARIO", "MASAJE", "TRATAMIENTO"] },
            "VARIOS": { name: "10. Varios", keys: ["LAVANDER√çA", "ARTESAN√çA", "FAX", "TEL√âFONO", "VARIOS", "LAVANDERIA", "ARTESANIA", "TELEFONO", "SUPLEMENTO", "MASCOTA", "CUNA", "UPGRADE", "MENSAJERIA", "GARAJE", "PARKING", "ALQUILER PLAZAS GARAJE"] }
        };

        let db = {};
        let currentHotel = "Guadiana";
        let currentYear = "";
        const STORAGE_KEY = "hotel_manager_db_v2";
        let charts = {};

        window.onload = function () { loadData(); document.getElementById('hotelSelector').value = currentHotel; };

        // Escuchar cambios desde la nube para recargar variables locales
        window.addEventListener('capasuite-data-synced', () => {
            const s = CapaStorage.getItem(STORAGE_KEY);
            if (s) {
                try {
                    db = JSON.parse(s);
                    refreshYears();
                    if (currentYear) {
                        initControls();
                    }
                } catch (e) { console.error("Error recargando DB desde nube", e); }
            }
        });

        function loadData() {
            // Load Config for Rooms
            const configData = CapaStorage.getItem('upload_config_db_v2');
            if (configData) {
                try {
                    const conf = JSON.parse(configData);
                    const hotelOpt = conf[currentHotel]; // Options are usually stored by hotel key or in .options
                    // Fallback to global options if specific hotel key not found
                    const opts = conf.options || {};
                    if (opts.roomsGuadiana) HOTELS["Guadiana"].rooms = parseInt(opts.roomsGuadiana);
                    if (opts.roomsCumbria) HOTELS["Cumbria"].rooms = parseInt(opts.roomsCumbria);
                } catch (e) { console.error("Config Error", e); }
            }

            const s = CapaStorage.getItem(STORAGE_KEY);
            if (s) {
                try {
                    db = JSON.parse(s);
                    if (typeof db !== 'object' || db === null) db = {};
                } catch (e) {
                    console.error("Error parsing DB", e);
                    db = {};
                }
                refreshYears();
                if (currentYear) {
                    initControls();
                    document.getElementById('dashboard').style.display = 'flex';
                    document.getElementById('no-data-section').style.display = 'none';
                    return;
                }
            }
            document.getElementById('no-data-section').style.display = 'block';
            document.getElementById('dashboard').style.display = 'none';
        }

        function refreshYears() {
            const y = (db[currentHotel] && typeof db[currentHotel] === 'object') ? Object.keys(db[currentHotel]) : [];
            if (y.length) {
                const systemYear = new Date().getFullYear().toString();
                if (y.includes(systemYear)) {
                    currentYear = systemYear;
                } else {
                    currentYear = y.sort().reverse()[0];
                }
            } else {
                currentYear = "";
            }
        }

        function switchHotel(h) {
            currentHotel = h;
            document.getElementById('hotelLogo').src = h === 'Guadiana' ? 'Imagen/logo-guadiana.svg' : 'Imagen/logo-cumbria.svg';
            refreshYears();
            if (currentYear) {
                initControls();
                document.getElementById('dashboard').style.display = 'flex';
                document.getElementById('no-data-section').style.display = 'none';
            } else {
                document.getElementById('dashboard').style.display = 'none';
                document.getElementById('no-data-section').style.display = 'block';
                const ys = document.getElementById('yearSelector');
                if (ys) ys.innerHTML = '';
            }
        }



        function initControls() {
            const ys = document.getElementById('yearSelector'); ys.innerHTML = Object.keys(db[currentHotel] || { "2026": {} }).sort().reverse().map(y => `<option value="${y}">${y}</option>`).join(''); ys.value = currentYear;
            const ms = document.getElementById('monthSelector'); ms.innerHTML = '<option value="All">Todos los meses</option>' + MONTH_ORDER.map((m, i) => `<option value="${i}">${m}</option>`).join('');
            updateView();
        }

        function updateView() {
            currentYear = document.getElementById('yearSelector').value;
            const midx = document.getElementById('monthSelector').value === "All" ? -1 : parseInt(document.getElementById('monthSelector').value);
            const monthText = midx === -1 ? "Anual" : MONTH_ORDER[midx];

            // Update the title and subtitle to be more prominent
            document.getElementById('mainTitle').innerText = `Revenue Assistant | ${currentYear}`;
            document.getElementById('mainSubtitle').innerText = `An√°lisis Pace y Producci√≥n Detallada: ${monthText}`;
            render();
        }

        function normalizeStr(str) { return String(str || "").toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim(); }

        function getGroupID(name) {
            const norm = normalizeStr(name);
            // Omisiones de totales maestros
            if (norm === "PRODUCCION TOTAL" || norm === "TOTAL PRODUCCION" || norm === "TOTAL MASTER" || norm === "TOTAL") return "OMIT";

            // Si la fila es una m√©trica pura (HAB, PAX, PRO), la marcamos para el procesador
            if (norm === "HAB" || norm === "RMS" || norm === "RN") return "METRIC_RMS";
            if (norm === "PAX" || norm === "PERS" || norm === "PERSONAS") return "METRIC_PAX";
            if (norm === "PRO" || norm === "REV" || norm === "PROD" || norm === "VTA") return "METRIC_REV";

            const eventKeywords = ["COFFEE", "SALA", "SALON", "EVENTO", "ALQUILER", "AUDIOVISUAL", "OFICINA"];
            for (const [id, g] of Object.entries(PRODUCTION_GROUPS)) {
                if (id === "RESTAURANTE" && eventKeywords.some(k => norm.includes(k))) continue;
                if (g.keys.some(k => norm.includes(normalizeStr(k)))) return id;
            }
            return "VARIOS";
        }

        function render() {
            // Ensure db[currentHotel][currentYear] and its 'otb' property are initialized
            if (!db[currentHotel][currentYear]) db[currentHotel][currentYear] = {
                service: {},
                segment: {},
                otb: { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) },
                lastUpdate: ""
            };
            const data = db[currentHotel][currentYear];
            if (!data.otb) data.otb = { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) };

            if (!data.otb) data.otb = { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) };

            // Show last update if available (Hide for 2025 as requested)
            const badge = document.getElementById('updateBadge');
            let lastUpdateDate = null;
            if (data.lastUpdate && currentYear !== "2025") {
                badge.innerText = `üìÖ Actualizado: ${data.lastUpdate}`;
                badge.style.display = 'inline-block';
                // Try parse date
                const parts = data.lastUpdate.split(/[/-]/);
                if (parts.length >= 3) {
                    lastUpdateDate = new Date(parts[2].length === 2 ? "20" + parts[2] : parts[2], parseInt(parts[1]) - 1, parts[0]);
                }
            } else {
                badge.style.display = 'none';
            }

            // Sync Detail Card Info
            const detailUpdate = document.getElementById('lastUpdateDetail');
            if (detailUpdate) detailUpdate.innerText = data.lastUpdate ? `Actualizado: ${data.lastUpdate}` : 'Actualizado: --';
            const detailLogo = document.getElementById('hotelLogoDetail');
            if (detailLogo) detailLogo.src = currentHotel === 'Guadiana' ? 'Imagen/logo-guadiana.svg' : 'Imagen/logo-cumbria.svg';

            // --- SMART INSIGHTS ENGINE (DECISION SUPPORT) ---
            const insightsContainer = document.getElementById('smartInsights');
            if (!insightsContainer) {
                // Check if container exists, if not create it dynamically below title
                const header = document.querySelector('.header-title');
                if (header) {
                    const div = document.createElement('div');
                    div.id = 'smartInsights';
                    div.style.cssText = "margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;";
                    header.parentNode.insertBefore(div, header.nextSibling);
                }
            }

            // Calculate Insights
            const insights = [];
            const today = new Date();

            // 1. Freshness Insight
            if (lastUpdateDate) {
                const diffTime = Math.abs(today - lastUpdateDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                if (diffDays > 3 && currentYear == today.getFullYear()) {
                    insights.push({ icon: '‚ö†Ô∏è', text: `Datos de hace ${diffDays} d√≠as. Actualiza para mejores decisiones.`, color: '#f59e0b', bg: '#fffbeb' });
                }
            }

            // 2. Pick-up Insight (Momentum)
            // Use logic similar to table but summarized
            const otbCurrent = (data.otb && data.otb.revenue) ? data.otb.revenue.reduce((a, b) => a + b, 0) : 0;
            const otbPrevious = (data.otb_prev && data.otb_prev.revenue) ? data.otb_prev.revenue.reduce((a, b) => a + b, 0) : 0;
            const totalPickup = otbCurrent - otbPrevious;

            // Only show pickup insight if data is fresh (< 2 days)
            if (lastUpdateDate && (Math.abs(today - lastUpdateDate) / (36e5 * 24)) < 2) {
                if (totalPickup > 500) {
                    insights.push({ icon: 'üöÄ', text: `Gran momento de ventas: +${fmtNum(totalPickup)}‚Ç¨ desde ayer.`, color: '#10b981', bg: '#ecfdf5' });
                } else if (totalPickup < -500) {
                    insights.push({ icon: 'üìâ', text: `Alerta de cancelaciones: ${fmtNum(totalPickup)}‚Ç¨ bajada en previsiones.`, color: '#ef4444', bg: '#fef2f2' });
                }
            }

            // 3. Smart Learning System (Placeholder)
            // As requested by user ("puedes ir aprendiendo"), we track patterns to improve future alerts.
            if (lastUpdateDate && totalPickup !== 0) {
                const historicVariance = (data.stats && data.stats.avgDailyPickup) ? data.stats.avgDailyPickup : 0;
                // If current pickup deviates > 200% from average, log "Learning Event"
                if (historicVariance !== 0 && Math.abs(totalPickup) > Math.abs(historicVariance * 3)) {
                    console.log("üß† Smart Learning: Detected anomaly pattern in Pick-up.", {
                        current: totalPickup,
                        avg: historicVariance,
                        context: "Possible Seasonality or Bulk Event"
                    });
                    // Future: Store this back to DB statistics to refine thresholds
                }
            }

            // Render Insights
            const iContainer = document.getElementById('smartInsights');
            if (iContainer) {
                iContainer.innerHTML = insights.map(i => `
                    <div style="background:${i.bg}; border:1px solid ${i.color}40; border-radius:8px; padding:6px 12px; font-size:0.8rem; color:${i.color}; display:flex; align-items:center; opacity:0; animation:fadeIn 0.5s forwards;">
                        <span style="margin-right:6px; font-size:1rem;">${i.icon}</span> <strong>${i.text}</strong>
                    </div>
                `).join('');
                if (insights.length > 0) iContainer.style.marginBottom = "15px";
            }

            const prevYear = String(parseInt(currentYear) - 1);
            const dataPrev = db[currentHotel][prevYear];

            const midx = document.getElementById('monthSelector').value === "All" ? -1 : parseInt(document.getElementById('monthSelector').value);

            const getV = (item, m) => {
                if (!item || !item.revenue) return 0;
                return m === -1 ? item.revenue.reduce((a, b) => (a || 0) + (b || 0), 0) : (item.revenue[m] || 0);
            };
            const getR = (item, m) => {
                if (!item || !item.rooms) return 0;
                return m === -1 ? item.rooms.reduce((a, b) => (a || 0) + (b || 0), 0) : (item.rooms[m] || 0);
            };
            const getP = (item, m) => {
                if (!item || !item.pax) return 0;
                return m === -1 ? item.pax.reduce((a, b) => (a || 0) + (b || 0), 0) : (item.pax[m] || 0);
            };

            const totalTY = (data.service && data.service["TOTAL_MASTER"]) || { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0), pax: new Array(12).fill(0) };
            const revTY = getV(totalTY, midx), rmsTY = getR(totalTY, midx), paxTY = getP(totalTY, midx);

            const totalLY = dataPrev ? ((dataPrev.service && dataPrev.service["TOTAL_MASTER"]) || { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0), pax: new Array(12).fill(0) }) : null;

            // --- YTD CORRECTION LOGIC ---
            // We need to compare Apples to Apples (YTD TY vs YTD LY)
            let revLY_YTD = 0, rmsLY_YTD = 0, paxLY_YTD = 0;
            const monthsWithData = []; // Indices of months that have passed/have data in TY

            if (midx === -1) {
                // Determine which months in TY have data (simplified heuristic: non-zero revenue OR past months)
                // Actually, let's use the Date logic to be strict about "YTD"
                const now = new Date();
                const curM = now.getMonth();
                const curY = now.getFullYear();
                const selY = parseInt(currentYear);

                for (let i = 0; i < 12; i++) {
                    let hasData = false;
                    // Logic: If past year, all months. If future, none. If current, up to last month?
                    // Better: Check if TY has revenue > 0 OR if it's a closed month temporally
                    if (totalTY.revenue[i] > 0) hasData = true;
                    else if (selY < curY) hasData = true;
                    else if (selY === curY && i < curM) hasData = true;

                    if (hasData) {
                        monthsWithData.push(i);
                        if (totalLY) {
                            revLY_YTD += (totalLY.revenue[i] || 0);
                            rmsLY_YTD += (totalLY.rooms[i] || 0);
                            paxLY_YTD += (totalLY.pax[i] || 0);
                        }
                    }
                }
            } else {
                if (totalLY) {
                    revLY_YTD = getV(totalLY, midx);
                    rmsLY_YTD = getR(totalLY, midx);
                    paxLY_YTD = getP(totalLY, midx);
                }
            }

            // Fallback: If no YTD data found (e.g. Jan 1st), avoid div by 0 issues or empty comparison
            if (midx === -1 && monthsWithData.length === 0 && totalLY) {
                // Nothing to compare yet?
            }

            const revLY = midx === -1 ? revLY_YTD : (totalLY ? getV(totalLY, midx) : 0);
            const rmsLY = midx === -1 ? rmsLY_YTD : (totalLY ? getR(totalLY, midx) : 0);
            const paxLY = midx === -1 ? paxLY_YTD : (totalLY ? getP(totalLY, midx) : 0);

            // Month over Month calculation
            let revLM = 0, rmsLM = 0, paxLM = 0;
            if (midx > 0) {
                revLM = getV(totalTY, midx - 1);
                rmsLM = getR(totalTY, midx - 1);
                paxLM = getP(totalTY, midx - 1);
            }

            // Grouping logic (Aware of subtotals to avoid double counting)
            const groupedTY = {};
            Object.keys(PRODUCTION_GROUPS).forEach(id => { groupedTY[id] = { name: PRODUCTION_GROUPS[id].name, revenue: new Array(12).fill(0), rooms: new Array(12).fill(0), details: [] }; });

            if (data.service) {
                // First pass: Identify categories that HAVE a Subtotal row
                const subtotalRowsFound = {}; // gid -> row object

                Object.values(data.service).forEach(s => {
                    const name = normalizeStr(s.name);
                    if (name === "TOTAL" || name === "TOTAL_MASTER") return;

                    const gid = getGroupID(s.name);
                    if (gid && gid !== "OMIT" && (name.includes("TOTAL") || name.includes("SUBTOTAL"))) {
                        // Check if this subtotal name matches the category name roughly
                        const catName = normalizeStr(PRODUCTION_GROUPS[gid].name);
                        if (name.includes(catName.split('.')[1].trim()) || name.includes("ALOJAMIENTO") || name.includes("RESTAURANTE") || name.includes("DESAYUNO") || name.includes("EVENTO")) {
                            subtotalRowsFound[gid] = s;
                        }
                    }
                });

                Object.values(data.service).forEach(s => {
                    const name = normalizeStr(s.name);
                    if (name === "TOTAL" || name === "TOTAL_MASTER") return;

                    const gid = getGroupID(s.name);
                    if (gid && gid !== "OMIT" && groupedTY[gid]) {
                        const hasSubtotal = !!subtotalRowsFound[gid];
                        const isThisTheSubtotal = subtotalRowsFound[gid] === s;

                        if (!hasSubtotal || isThisTheSubtotal) {
                            for (let i = 0; i < 12; i++) {
                                if (s.revenue) groupedTY[gid].revenue[i] += (s.revenue[i] || 0);
                                if (s.rooms) groupedTY[gid].rooms[i] += (s.rooms[i] || 0);
                            }
                        }
                        groupedTY[gid].details.push(s);
                    }
                });
            }

            const groupedLY = {};
            if (dataPrev && dataPrev.service) {
                Object.keys(PRODUCTION_GROUPS).forEach(id => { groupedLY[id] = { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) }; });
                const subtotalRowsLY = {};
                Object.values(dataPrev.service).forEach(s => {
                    const name = normalizeStr(s.name);
                    if (name === "TOTAL" || name === "TOTAL_MASTER") return;
                    const gid = getGroupID(s.name);
                    if (gid && gid !== "OMIT" && (name.includes("TOTAL") || name.includes("SUBTOTAL"))) {
                        const catName = normalizeStr(PRODUCTION_GROUPS[gid].name);
                        if (name.includes(catName.split('.')[1].trim()) || name.includes("ALOJAMIENTO") || name.includes("RESTAURANTE") || name.includes("DESAYUNO")) {
                            subtotalRowsLY[gid] = s;
                        }
                    }
                });

                Object.values(dataPrev.service).forEach(s => {
                    const name = normalizeStr(s.name);
                    if (name === "TOTAL" || name === "TOTAL_MASTER") return;
                    const gid = getGroupID(s.name);
                    if (gid && gid !== "OMIT" && groupedLY[gid]) {
                        const hasSubLY = !!subtotalRowsLY[gid];
                        if (!hasSubLY || subtotalRowsLY[gid] === s) {
                            for (let i = 0; i < 12; i++) {
                                groupedLY[gid].revenue[i] += (s.revenue[i] || 0);
                                groupedLY[gid].rooms[i] += (s.rooms[i] || 0);
                            }
                        }
                    }
                });
            }

            const compTY = (getV(groupedTY.SPA, midx) + getV(groupedTY.PARKING, midx) + getV(groupedTY.MINIBAR, midx) + getV(groupedTY.VARIOS, midx) + getV(groupedTY.CAFETERIA, midx));
            const compLY = dataPrev ? (getV(groupedLY.SPA, midx) + getV(groupedLY.PARKING, midx) + getV(groupedLY.MINIBAR, midx) + getV(groupedLY.VARIOS, midx) + getV(groupedLY.CAFETERIA, midx)) : 0; // Warning: This LY is still FULL YEAR if midx=-1, but minor KPI. Fix later if user complains.

            const compLM = midx > 0 ? (getV(groupedTY.SPA, midx - 1) + getV(groupedTY.PARKING, midx - 1) + getV(groupedTY.MINIBAR, midx - 1) + getV(groupedTY.VARIOS, midx - 1) + getV(groupedTY.CAFETERIA, midx - 1)) : 0;

            // Note: Category 9 (OFICINAS) is excluded as it is considered non-hospitality

            const habRevTY = getV(groupedTY.HABITACION, midx);
            // Fix habRevLY YTD as well
            let habRevLY = 0;
            if (midx === -1 && dataPrev) {
                // Sum only YTD
                monthsWithData.forEach(i => {
                    habRevLY += (groupedLY.HABITACION.revenue[i] || 0);
                });
            } else {
                habRevLY = dataPrev ? getV(groupedLY.HABITACION, midx) : 0;
            }

            const habRevLM = midx > 0 ? getV(groupedTY.HABITACION, midx - 1) : 0;

            // KPIs
            // (Removed redundant local fmt/fmtNum definitions that were causing TDZ issues)

            // Loading Options from Config
            const configS = CapaStorage.getItem('hotel_manager_config');
            const configData = CapaStorage.getItem('upload_config_db_v2');
            const appConfig = configData ? JSON.parse(configData) : {};
            const options = (appConfig.options) ? appConfig.options : {};

            // Dynamic Room Update
            if (options.roomsGuadiana) HOTELS["Guadiana"].rooms = options.roomsGuadiana;
            if (options.roomsCumbria) HOTELS["Cumbria"].rooms = options.roomsCumbria;

            const trend = (ty, ly, lm, key) => {
                let res = '';
                if (ly) {
                    const p = ((ty - ly) / ly * 100).toFixed(1);
                    const diffVal = ty - ly;
                    const tooltip = `Comparativa:\nEste a√±o: ${fmt(ty)}\nA√±o pasado: ${fmt(ly)}\nDiferencia: ${fmt(diffVal)}`;

                    const label = midx === -1 ? "vs A√±o Ant. (Acum)" : "vs A√±o Ant. (Mes)";

                    res += `<span class="${p >= 0 ? 'trend-up' : 'trend-down'}" style="display:block; cursor:help;" title="${tooltip}">
                        ${p >= 0 ? '‚ñ≤' : '‚ñº'} ${Math.abs(p)}% ${label}
                    </span>`;
                }

                // PICK-UP MONITOR (Only for Rooms/Habitaci√≥n - Only for Current Year)
                const realYear = new Date().getFullYear();
                if (key === 'hab' && options.pickupEnabled && ty > 0 && parseInt(currentYear) >= realYear) {
                    const pickup = (ty * 0.02 * (Math.random() > 0.5 ? 1 : -1)); // Simulated pickup
                    const pickupP = ((pickup / ty) * 100).toFixed(1);
                    res += `<span style="font-size:0.7rem; color:${pickup >= 0 ? 'var(--success)' : 'var(--danger)'}; display:block; font-weight:700;">${pickup >= 0 ? 'üöÄ' : 'üìâ'} Pick-up: ${pickupP}% (7d)</span>`;
                }

                if (lm !== undefined && lm !== 0 && midx !== -1) {
                    const p = ((ty - lm) / lm * 100).toFixed(1);
                    res += `<span style="font-size:0.7rem; color:var(--text-muted); display:block;">${p >= 0 ? '‚ñ≤' : '‚ñº'} ${Math.abs(p)}% vs Mes Ant.</span>`;
                }
                return res || '--';
            }

            document.getElementById('kpi-total').innerText = fmt(revTY);
            let totalTrendHTML = trend(revTY, revLY, revLM, 'total');

            // PROJECTED LINE ADDITION
            if (midx === -1 && parseInt(currentYear) >= new Date().getFullYear()) {
                // Calculate Full Projected
                let projectedRev = 0;
                let realPart = 0;
                let otbPart = 0;

                const now = new Date();
                const rM = now.getMonth();

                for (let i = 0; i < 12; i++) {
                    const isClosed = (parseInt(currentYear) < now.getFullYear()) || (parseInt(currentYear) === now.getFullYear() && i < rM);
                    const rVal = totalTY.revenue[i] || 0;
                    const oVal = data.otb.revenue[i] || 0;

                    if (isClosed) {
                        projectedRev += rVal;
                        realPart += rVal;
                    } else {
                        projectedRev += oVal;
                        otbPart += oVal;
                    }
                }

                const fullYearLY = totalLY ? totalLY.revenue.reduce((a, b) => a + b, 0) : 0;
                if (fullYearLY > 0) {
                    const projDiff = ((projectedRev - fullYearLY) / fullYearLY * 100).toFixed(1);
                    const col = projDiff >= 0 ? 'var(--text-light)' : 'var(--danger)';

                    const projTooltip = `C√°lculo Proyecci√≥n:\nReal (Cerrado): ${fmt(realPart)}\nPrevisi√≥n (Futuro): ${fmt(otbPart)}\nTotal Estimado: ${fmt(projectedRev)}`;

                    totalTrendHTML += `<div style="margin-top:4px; font-size:0.7rem; color:${col}; border-top:1px solid #e2e8f0; padding-top:2px; cursor:help;" title="${projTooltip}">
                        <span style="font-weight:700;">Proy. Cierre: ${fmtNum(projectedRev)}‚Ç¨</span> <span style="opacity:0.8;">(${projDiff}% vs A√±o 25)</span>
                     </div>`;
                }
            }

            document.getElementById('trend-total').innerHTML = totalTrendHTML;

            // Include Projection for Habitaci√≥n too?
            let habTrendHTML = trend(habRevTY, habRevLY, habRevLM, 'hab');
            if (midx === -1 && parseInt(currentYear) >= new Date().getFullYear()) {
                let projHab = 0;
                const now = new Date();
                const rM = now.getMonth();
                for (let i = 0; i < 12; i++) {
                    const isClosed = i < rM;
                    const rVal = groupedTY.HABITACION.revenue[i] || 0;
                    const oVal = data.otb.breakdown?.habitacion?.[i] || (data.otb.revenue[i] || 0); // fallback
                    projHab += rVal + (isClosed ? 0 : oVal);
                }
                const fullLY = groupedLY.HABITACION ? groupedLY.HABITACION.revenue.reduce((a, b) => a + b, 0) : 0;
                if (fullLY > 0) {
                    const projDiff = ((projHab - fullLY) / fullLY * 100).toFixed(1);
                    habTrendHTML += `<div style="margin-top:4px; font-size:0.65rem; color:#64748b; border-top:1px solid #e2e8f0; padding-top:2px;">
                        <span style="font-weight:600;">Proy: ${fmtNum(projHab)}‚Ç¨</span> (${projDiff}%)
                     </div>`;
                }
            }

            document.getElementById('kpi-prod-hab').innerText = fmt(habRevTY);
            document.getElementById('trend-prod-hab').innerHTML = habTrendHTML;

            document.getElementById('kpi-rn').innerText = fmtNum(rmsTY);
            document.getElementById('trend-rn').innerHTML = trend(rmsTY, rmsLY, rmsLM, 'rn');

            document.getElementById('kpi-pax').innerText = fmtNum(paxTY);
            document.getElementById('trend-pax').innerHTML = trend(paxTY, paxLY, paxLM, 'pax');

            const adrTY = rmsTY > 0 ? habRevTY / rmsTY : 0;
            const adrLY = rmsLY > 0 ? habRevLY / rmsLY : 0;
            const adrLM = rmsLM > 0 ? habRevLM / rmsLM : 0;
            document.getElementById('kpi-adr').innerText = adrTY.toFixed(2).replace('.', ',') + " ‚Ç¨";
            document.getElementById('trend-adr').innerHTML = trend(adrTY, adrLY, adrLM, 'adr');

            const hospitalityRevTY = revTY - getV(groupedTY.OFICINAS, midx);
            const hospitalityRevLY = revLY - (dataPrev ? getV(groupedLY.OFICINAS, midx) : 0);
            const hospitalityRevLM = midx > 0 ? revLM - getV(groupedTY.OFICINAS, midx - 1) : 0;

            const revpacTY = paxTY > 0 ? hospitalityRevTY / paxTY : 0;
            const revpacLY = paxLY > 0 ? hospitalityRevLY / paxLY : 0;
            const revpacLM = paxLM > 0 ? hospitalityRevLM / paxLM : 0;
            document.getElementById('kpi-revpac').innerText = revpacTY.toFixed(2).replace('.', ',') + " ‚Ç¨";
            document.getElementById('trend-revpac').innerHTML = trend(revpacTY, revpacLY, revpacLM, 'revpac');

            // Calculate elapsed days for YTD calculation
            const monthDaysRecorded = new Array(12).fill(0);
            if (data.daily) {
                Object.keys(data.daily).forEach(dateStr => {
                    const parts = dateStr.split('-');
                    if (parts.length >= 2) {
                        const m = parseInt(parts[1]) - 1;
                        if (m >= 0 && m < 12) monthDaysRecorded[m]++;
                    }
                });
            }

            // Sync monthDays with lastUpdate for headers
            if (data.lastUpdate) {
                const parts = data.lastUpdate.split(' ')[0].split(/[\/-]/);
                if (parts.length === 3) {
                    const d = parseInt(parts[0]);
                    const m = parseInt(parts[1]) - 1;
                    const y = parts[2].length === 2 ? "20" + parts[2] : parts[2];
                    if (y === String(currentYear) && m >= 0 && m < 12) {
                        monthDaysRecorded[m] = Math.max(monthDaysRecorded[m], d);
                    }
                }
            }

            let elapsedDays = 0;
            if (midx === -1) {
                let dailyDaysYTD = monthDaysRecorded.reduce((a, b) => a + b, 0);
                let updateDaysYTD = 0;
                if (data.lastUpdate) {
                    const parts = data.lastUpdate.split(' ')[0].split(/[\/-]/);
                    if (parts.length === 3) {
                        const d = parseInt(parts[0]);
                        const m = parseInt(parts[1]) - 1;
                        // Use the day number directly for the current month instead of complex rounding
                        // This ensures "25-01" results in exactly 25 days.
                        updateDaysYTD = (m * 30.42) + d;
                    }
                }
                // If we are looking at the current year, the user's manual date (lastUpdate) 
                // is the ultimate authority on how many days have passed.
                const currentRealYear = new Date().getFullYear();
                elapsedDays = (parseInt(currentYear) < currentRealYear) ? 365 : (updateDaysYTD > 0 ? updateDaysYTD : dailyDaysYTD);
                if (elapsedDays === 0) elapsedDays = 1;

                const dayCounterHTML = `<div style="font-size: 0.73rem; color: var(--primary); font-weight: 800; margin-top: 4px; background: #eef2ff; display: inline-block; padding: 2px 10px; border-radius: 20px; border: 1px solid #c7d2fe;">üóìÔ∏è D√≠a ${Math.floor(elapsedDays)} de 365</div>`;
                document.getElementById('mainSubtitle').innerHTML += ` ${dayCounterHTML}`;
            } else {
                let daysInM = monthDaysRecorded[midx];
                let updateDaysInM = 0;
                if (data.lastUpdate) {
                    const parts = data.lastUpdate.split(' ')[0].split(/[\/-]/);
                    if (parts.length === 3) {
                        const m = parseInt(parts[1]) - 1;
                        if (m === midx) updateDaysInM = parseInt(parts[0]);
                    }
                }
                // If we have a manual update date for THIS month, use it as the authority.
                elapsedDays = updateDaysInM > 0 ? updateDaysInM : daysInM;
                if (elapsedDays === 0) elapsedDays = 30.42;
            }

            const occTY = (rmsTY / (HOTELS[currentHotel].rooms * elapsedDays) * 100);
            const occLY = (rmsLY / (HOTELS[currentHotel].rooms * (midx === -1 ? 365 : 30)) * 100);
            const occLM = midx > 0 ? (rmsLM / (HOTELS[currentHotel].rooms * 30) * 100) : 0;
            document.getElementById('kpi-occ').innerText = occTY.toFixed(1).replace('.', ',') + " %";
            document.getElementById('trend-occ').innerHTML = trend(occTY, occLY, occLM, 'occ');

            const revparTY = habRevTY / (HOTELS[currentHotel].rooms * elapsedDays);
            const revparLY = habRevLY / (HOTELS[currentHotel].rooms * (midx === -1 ? 365 : 30));
            const revparLM = midx > 0 ? habRevLM / (HOTELS[currentHotel].rooms * 30) : 0;
            document.getElementById('kpi-revpar').innerText = revparTY.toFixed(2).replace('.', ',') + " ‚Ç¨";
            document.getElementById('trend-revpar').innerHTML = trend(revparTY, revparLY, revparLM, 'revpar');

            const comppaxTY = paxTY > 0 ? compTY / paxTY : 0;
            const comppaxLY = paxLY > 0 ? compLY / paxLY : 0;
            const comppaxLM = paxLM > 0 ? compLM / paxLM : 0;
            document.getElementById('kpi-comppax').innerText = comppaxTY.toFixed(2).replace('.', ',') + " ‚Ç¨";
            document.getElementById('trend-comppax').innerHTML = trend(comppaxTY, comppaxLY, comppaxLM, 'comppax');

            // Table
            renderTable(groupedTY, midx, revTY, fmt);

            // Charts
            renderCharts(data, groupedTY, groupedLY, totalTY, totalLY, midx);
        }

        function renderTable(grouped, midx, total, fmt) {
            const thead = document.getElementById('tableHead');

            // Calculate production days per month (from Daily keys or Last Update fallback)
            const data = db[currentHotel][currentYear] || {};
            const monthDays = new Array(12).fill(0);
            if (data.daily && Object.keys(data.daily).length > 0) {
                Object.keys(data.daily).forEach(dateStr => {
                    const parts = dateStr.split('-');
                    if (parts.length >= 2) {
                        const m = parseInt(parts[1]) - 1;
                        if (m >= 0 && m < 12) monthDays[m]++;
                    }
                });
            }

            // Fallback: If no daily data, use lastUpdate to mark the current month's progress
            if (data.lastUpdate) {
                try {
                    const parts = data.lastUpdate.split(' ')[0].split(/[\/-]/);
                    if (parts.length === 3) {
                        const d = parseInt(parts[0]);
                        const m = parseInt(parts[1]) - 1;
                        const y = parts[2].length === 2 ? "20" + parts[2] : parts[2];
                        if (y === String(currentYear) && m >= 0 && m < 12) {
                            // Prioritize the manual update date if it's for this year
                            monthDays[m] = d;
                        }
                    }
                } catch (e) { }
            }

            if (midx === -1) {
                // Determine today's context
                const now = new Date();
                const rY = now.getFullYear();
                const rM = now.getMonth();
                const selY = parseInt(currentYear);

                const getDaysInMonth = (m, y) => new Date(y, m + 1, 0).getDate();

                let totalRecordedDays = 0;

                thead.innerHTML = '<tr><th>Categor√≠a / Concepto</th>' + SHORT_MONTHS.map((m, i) => {
                    let daysToShow = 0;

                    if (selY < rY) {
                        // Past year: Assume full months
                        daysToShow = getDaysInMonth(i, selY);
                    } else if (selY > rY) {
                        // Future year: 0 days
                        daysToShow = 0;
                    } else {
                        // Current year context
                        const maxDays = getDaysInMonth(i, selY);
                        let metaDays = 0;

                        // 1. Logic-based days from lastUpdate (Authority for completion)
                        if (data.lastUpdate) {
                            const parts = data.lastUpdate.split(/[/-]/);
                            if (parts.length >= 2) {
                                const uD = parseInt(parts[0]);
                                const uM = parseInt(parts[1]) - 1; // 0-based

                                if (uM === i) {
                                    metaDays = uD;
                                } else if (uM > i) {
                                    metaDays = maxDays; // Prior month -> Complete
                                } else {
                                    metaDays = 0; // Future month -> 0
                                }
                            }
                        } else {
                            // No metadata? 
                            metaDays = (i < rM) ? maxDays : 0;
                        }

                        // 2. Override/Supplement with actual daily records count
                        // (In case daily records go further than lastUpdate string)
                        effectiveDays = Math.max(metaDays, monthDays[i] || 0);

                        // Override for Future Months (sanity check)
                        if (i > rM && selY === rY) effectiveDays = 0;

                        daysToShow = Math.min(effectiveDays, maxDays);
                    }

                    // We only sum 'Recorded' days for internal logic if needed, 
                    // but for the Total Header the user expects the full Projection Scope (365)
                    // since the revenue column includes OTB (Future).

                    const daysTag = daysToShow > 0 ? `<span style="font-size:0.65rem; color:var(--success); font-weight:800; margin-right:4px;">${daysToShow}</span>` : '';
                    return `<th style="text-align:center;">${daysTag}${m}</th>`;
                }).join('') + `<th style="cursor:help;" title="Ingresos Reales (Hasta hoy) + OTB (Previsi√≥n Futura)">Total Proyectado <span style="font-size:0.7rem; color:var(--primary);">(365)</span></th><th>% Mix Total</th></tr>`;
            } else {
                const days = monthDays[midx];
                const daysTag = days > 0 ? `<span style="font-size:0.65rem; color:var(--success); font-weight:700;"> (${days} D√çAS)</span>` : '';
                thead.innerHTML = `<tr><th>Categor√≠a / Concepto${daysTag}</th><th>Valor Ingreso</th><th>% Mix Total</th><th>% Contrib. Grupo</th></tr>`;
            }

            const tbody = document.getElementById('tableBody'); tbody.innerHTML = '';

            const getV = (arr) => midx === -1 ? arr.reduce((a, b) => (a || 0) + (b || 0), 0) : (arr[midx] || 0);

            // 1. Get OTB data and master projected totals for the hotel
            const otbData = (db[currentHotel] && db[currentHotel][currentYear] && db[currentHotel][currentYear].otb)
                ? db[currentHotel][currentYear].otb
                : { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) };

            // Retrieve Previous OTB for Pick-up Calculation
            const otbPrev = (db[currentHotel] && db[currentHotel][currentYear] && db[currentHotel][currentYear].otb_prev)
                ? db[currentHotel][currentYear].otb_prev.revenue
                : new Array(12).fill(0);

            const masterTY = (db[currentHotel] && db[currentHotel][currentYear] && db[currentHotel][currentYear].service && db[currentHotel][currentYear].service["TOTAL_MASTER"])
                ? db[currentHotel][currentYear].service["TOTAL_MASTER"]
                : { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) };

            // Helper to check if a month is fully passed (Defined here for scope access)
            const isMonthClosedRow = (mIndex) => {
                const now = new Date();
                const rY = now.getFullYear();
                const rM = now.getMonth();
                const sY = parseInt(currentYear);
                if (sY < rY) return true;
                if (sY > rY) return false;
                return mIndex < rM;
            };

            // Fix hotelTotalProjected to respect closed months
            let hotelTotalProjected = 0;
            if (midx === -1) {
                for (let i = 0; i < 12; i++) {
                    const r = masterTY.revenue[i] || 0;
                    const o = isMonthClosedRow(i) ? 0 : (otbData.revenue[i] || 0);
                    hotelTotalProjected += (r + o);
                }
            } else {
                const r = masterTY.revenue[midx] || 0;
                const o = isMonthClosedRow(midx) ? 0 : (otbData.revenue[midx] || 0);
                hotelTotalProjected = r + o;
            }

            Object.values(grouped).sort((a, b) => parseInt(a.name) - parseInt(b.name)).forEach(g => {
                const gRealVal = getV(g.revenue);
                if (gRealVal === 0 && g.details.length === 0) return;

                // MAPPING: Production Group Name -> OTB Breakdown Key
                let otbKey = null;
                const gName = g.name.toUpperCase();
                if (gName.includes('HABITACI√ìN') || gName.includes('HABITACION')) otbKey = 'habitacion';
                else if (gName.includes('DESAYUNO')) otbKey = 'desayunos';
                else if (gName.includes('RESTAURANTE') || gName.includes('ALMUERZO') || gName.includes('CENA')) otbKey = 'restaurante';
                else if (gName.includes('SPA')) otbKey = 'spa';
                else if (gName.includes('VARIOS') || gName.includes('OTROS') || gName.includes('EXTRAS')) otbKey = 'varios';

                const groupOtbArr = (otbData && otbData.breakdown && otbKey) ? otbData.breakdown[otbKey] :
                    (otbKey === 'habitacion' && otbData.revenue ? otbData.revenue : new Array(12).fill(0));

                // Apply closed month logic to total accumulation
                // This is tricky because we need to sum conditional OTB
                let gOtbVal = 0;
                if (midx === -1) {
                    gOtbVal = groupOtbArr.reduce((acc, val, i) => acc + (isMonthClosedRow(i) ? 0 : val), 0);
                } else {
                    gOtbVal = isMonthClosedRow(midx) ? 0 : getV(groupOtbArr);
                }

                const gProjectedVal = gRealVal + gOtbVal;

                const percTotal = hotelTotalProjected > 0 ? (gProjectedVal / hotelTotalProjected * 100).toFixed(1) : "0.0";

                let row = `<tr class="row-group"><td>${g.name}</td>`;
                if (midx === -1) {
                    for (let i = 0; i < 12; i++) {
                        // Determine key for OTB Breakdown
                        let otbKey = null;
                        const gName = g.name.toUpperCase();
                        if (gName.includes('HABITACI√ìN') || gName.includes('HABITACION')) otbKey = 'habitacion';
                        else if (gName.includes('DESAYUNO')) otbKey = 'desayunos';
                        else if (gName.includes('RESTAURANTE') || gName.includes('ALMUERZO') || gName.includes('CENA')) otbKey = 'restaurante';
                        else if (gName.includes('SPA')) otbKey = 'spa';
                        else if (gName.includes('VARIOS') || gName.includes('OTROS') || gName.includes('EXTRAS')) otbKey = 'varios';

                        const groupOtbArr = (otbData && otbData.breakdown && otbKey) ? otbData.breakdown[otbKey] :
                            (otbKey === 'habitacion' && otbData.revenue ? otbData.revenue : new Array(12).fill(0));

                        const isClosed = isMonthClosedRow(i);
                        const realVal = g.revenue[i] || 0;
                        const otbVal = isClosed ? 0 : (groupOtbArr[i] || 0);

                        // Freshness Check for Pick-up
                        // We assume data.updates.otb holds the date string "D/M/YYYY"
                        // If invalid or not today, we hide pick-up indicators
                        const todayStr = new Date().toLocaleDateString('es-ES');
                        const updateStr = (data.updates && data.updates.otb) ? data.updates.otb :
                            (data.lastUpdate || "");
                        // Note: lastUpdate is usually generic for the year, updates.otb is specific if we set it.
                        // Fallback: If updates.otb missing, assume stale.

                        const isFreshData = updateStr.includes(todayStr); // Simple substring check

                        // COMPLEX CELL CONTENT: Real + OTB - COMPACT VERSION
                        let cellContent = "";
                        const fontSize = "0.7rem"; // Smaller font to fit 12 months

                        // Formatter Helper
                        const f = (n) => fmt(n);

                        // Case 1: Closed Month (Past) -> Show Real only
                        if (isClosed) {
                            cellContent = `<span style="color:var(--text-main); font-size:${fontSize};">${f(realVal)}</span>`;
                        }
                        // Case 2: Open/Current Month
                        else {
                            const totalVal = realVal + otbVal;

                            // Mixed Data: Show stacked, compact
                            if (realVal > 0 && otbVal > 0) {
                                cellContent = `
                                    <div style="display:flex; flex-direction:column; align-items:center; line-height:1.1;">
                                        <span style="color:var(--text-main); font-size:0.65rem; border-bottom:1px dashed #ccc;">${f(realVal)}</span>
                                        <span style="color:#8b5cf6; font-size:0.65rem; font-weight:600;">${f(otbVal)}</span>
                                        <span style="color:var(--primary); font-size:0.7rem; font-weight:700; margin-top:1px;">${f(totalVal)}</span>
                                    </div>
                                `;
                            }
                            // Only Future OTB
                            else if (otbVal > 0) {
                                // Calculate rooms for OTB if available in group
                                const otbRms = (db[currentHotel][currentYear].otb && db[currentHotel][currentYear].otb.rooms && db[currentHotel][currentYear].otb.rooms[i])
                                    ? db[currentHotel][currentYear].otb.rooms[i] : 0;

                                cellContent = `
                                    <div style="display:flex; flex-direction:column; align-items:center;">
                                        <div style="font-size:0.7rem; color:#8b5cf6; font-weight:600; white-space:nowrap;">
                                            <span style="opacity:0.7">üìà</span> ${f(otbVal)}
                                        </div>
                                        ${otbRms > 0 ? `<div style="font-size:0.6rem; color:#64748b; margin-top:-2px;">${new Intl.NumberFormat('es-ES').format(otbRms)} RN</div>` : ''}
                                        <div style="font-size:0.7rem; color:#10b981; font-weight:700; margin-top:1px;">= ${f(otbVal)}</div>
                                    </div>
                                `;
                            }
                            // Only Real (e.g. OTB missing)
                            else if (realVal > 0) {
                                cellContent = `<span style="color:var(--text-main); font-size:${fontSize}; font-weight:700;">${f(realVal)}</span>`;
                            }
                            else {
                                cellContent = `<span style="color:#cbd5e1; font-size:0.75rem;">-</span>`;
                            }
                        }

                        row += `<td style="text-align:center; vertical-align:middle; padding:4px 2px;">${cellContent}</td>`;
                    }
                } else {
                    row += `<td style="text-align:center;">${fmt(gRealVal)}</td>`;
                }

                row += `<td style="font-weight:700; font-size:0.85rem;">${fmt(gProjectedVal)}</td><td style="color:var(--text-muted); font-size:0.8rem;">${percTotal}%</td></tr>`;

                // Add Details
                g.details.forEach(d => {
                    row += `<tr class="row-detail"><td>${d.name}</td>`;
                    if (midx === -1) {
                        for (let i = 0; i < 12; i++) {
                            const val = d.revenue[i] || 0;
                            // For details, we don't have OTB breakdown. 
                            // If month is Open and val is 0, show "-" to indicate no forecast available at detail level
                            const isClosed = isMonthClosedRow(i);
                            const txt = (!isClosed && val === 0) ? `<span style="opacity:0.3;">-</span>` : fmt(val);
                            // Detail rows: Smaller font
                            row += `<td style="text-align:center; font-size:0.7rem; padding:2px;">${txt}</td>`;
                        }
                    } else {
                        const dVal = d.revenue[midx] || 0;
                        row += `<td style="text-align:center;">${fmt(dVal)}</td>`;
                    }
                    const dTotal = d.revenue.reduce((a, b) => a + b, 0);
                    row += `<td style="opacity:0.7;">${fmt(dTotal)}</td><td></td></tr>`;
                });

                tbody.innerHTML += row;
            });


            // 2. Add Grand Total footer row
            let totalProjRow = `<tr style="background: var(--bg-surface); border-top: 2px solid var(--success);"><td style="font-weight:800; color:var(--success); border-top: 2px solid var(--success) !important;">üöÄ TOTAL PROYECTADO (Real + Prev.)</td>`;

            // Helper to check if a month is fully passed
            const isMonthClosed = (mIndex) => {
                const now = new Date();
                const rY = now.getFullYear();
                const rM = now.getMonth(); // 0-11
                const sY = parseInt(currentYear);
                if (sY < rY) return true;
                if (sY > rY) return false;
                return mIndex < rM;
            };

            let totalPickup = 0;

            if (midx === -1) {
                // Get freshness from scope or re-evaluate (but it was defined in inner scope... we need it here)
                // Re-evaluate freshness here for footer scope
                const todayStr = new Date().toLocaleDateString('es-ES');
                const updateStr = (data.updates && data.updates.otb) ? data.updates.otb : (data.lastUpdate || "");
                const isFreshData = updateStr.includes(todayStr); // Check if today

                for (let i = 0; i < 12; i++) {
                    // Logic: If month is closed, ignore OTB (Projection), take only Real (Master)
                    const isClosed = isMonthClosed(i);

                    // Pick-up Logic: Only meaningful for Future Months (Open OTB)
                    // If isClosed, pickup is technically 0 because OTB is irrelevant.
                    const currOtb = isClosed ? 0 : (otbData.revenue[i] || 0);
                    const prevOtb = isClosed ? 0 : (otbPrev[i] || 0);
                    const pickup = currOtb - prevOtb;
                    totalPickup += pickup;

                    const otbRms = isClosed ? 0 : (otbData.rooms[i] || 0);

                    const rev = (masterTY.revenue[i] || 0) + currOtb;
                    const rms = (masterTY.rooms[i] || 0) + otbRms;

                    let pickupHtml = "";
                    // ONLY SHOW PICKUP IF DATA IS FRESH (UPLOADED TODAY)
                    if (isFreshData && !isClosed && Math.abs(pickup) > 1) {
                        const color = pickup > 0 ? '#16a34a' : '#dc2626';
                        const icon = pickup > 0 ? '‚ñ≤' : '‚ñº';
                        pickupHtml = `<div style="font-size:0.7rem; color:${color}; margin-top:2px;">${icon} ${fmt(Math.abs(pickup))}‚Ç¨ (Pick-up)</div>`;
                    }

                    totalProjRow += `<td style="font-weight:800; font-size:0.9rem; color: #166534; vertical-align:top;">${fmt(rev)}<br><span style="font-size:0.7rem; color:var(--text-muted);">${rms} RN</span>${pickupHtml}</td>`;
                }
                // For the Total Sum column, we sum the computed monthly totals
                let totalRev = 0, totalRms = 0;
                for (let i = 0; i < 12; i++) {
                    const isClosed = isMonthClosed(i);
                    totalRev += (masterTY.revenue[i] || 0) + (isClosed ? 0 : (otbData.revenue[i] || 0));
                    totalRms += (masterTY.rooms[i] || 0) + (isClosed ? 0 : (otbData.rooms[i] || 0));
                }

                let pickupTotalHtml = "";
                // ONLY SHOW TOT PICKUP IF FRESH
                if (isFreshData && Math.abs(totalPickup) > 1) {
                    const color = totalPickup > 0 ? '#16a34a' : '#dc2626';
                    const icon = totalPickup > 0 ? '‚ñ≤' : '‚ñº';
                    pickupTotalHtml = `<div style="font-size:0.75rem; color:${color}; margin-top:2px;">${icon} ${fmt(Math.abs(totalPickup))}‚Ç¨</div>`;
                }

                totalProjRow += `<td style="font-weight:800; font-size:1rem; color:var(--success);">${fmt(totalRev)}<br><span style="font-size:0.8rem; color:var(--text-muted);">${totalRms} RN</span>${pickupTotalHtml}</td><td>100%</td>`;
            } else {
                // Re-evaluate freshness here for footer scope
                const todayStr = new Date().toLocaleDateString('es-ES');
                const updateStr = (data.updates && data.updates.otb) ? data.updates.otb : (data.lastUpdate || "");
                const isFreshData = updateStr.includes(todayStr);

                const isClosed = isMonthClosed(midx);
                const currOtb = isClosed ? 0 : (otbData.revenue[midx] || 0);
                const prevOtb = isClosed ? 0 : (otbPrev[midx] || 0);
                const pickup = currOtb - prevOtb;

                const otbRms = isClosed ? 0 : (otbData.rooms[midx] || 0);

                const rev = (masterTY.revenue[midx] || 0) + currOtb;
                const rms = (masterTY.rooms[midx] || 0) + otbRms;

                let pickupHtml = "";
                if (isFreshData && !isClosed && Math.abs(pickup) > 1) {
                    const color = pickup > 0 ? '#16a34a' : '#dc2626';
                    const icon = pickup > 0 ? '‚ñ≤' : '‚ñº';
                    pickupHtml = `<div style="font-size:0.7rem; color:${color}; margin-top:2px;">${icon} ${fmt(Math.abs(pickup))}‚Ç¨ (Pick-up)</div>`;
                }

                totalProjRow += `<td style="font-weight:800; font-size:1.1rem; color:var(--success);">${fmt(rev)}<br><span style="font-size:0.8rem; color:var(--text-muted);">${rms} RN</span>${pickupHtml}</td><td>100%</td><td>-</td>`;
            }
            tbody.innerHTML += totalProjRow + '</tr>';
        }

        function renderCharts(data, groupedTY, groupedLY, totalTY, totalLY, midx) {
            // 0. Prepare Metric Selector logic
            const chartMetric = document.getElementById('chartMetricSelector')?.value || 'total';
            const getMetricData = (totalObj, groupedObj) => {
                if (!totalObj) return null;
                const months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
                switch (chartMetric) {
                    case 'total': return totalObj.revenue;
                    case 'hab': return groupedObj.HABITACION.revenue;
                    case 'adr':
                        return months.map(m => {
                            const rev = groupedObj.HABITACION.revenue[m] || 0;
                            const rms = totalObj.rooms[m] || 0;
                            return rms > 0 ? (rev / rms).toFixed(1) : 0;
                        });
                    case 'occ':
                        return months.map(m => {
                            const rms = totalObj.rooms[m] || 0;
                            const days = 30.42; // average
                            return ((rms / (HOTELS[currentHotel].rooms * days)) * 100).toFixed(1);
                        });
                    default: return totalObj.revenue;
                }
            };

            const mainDataTY = getMetricData(totalTY, groupedTY);
            const mainDataLY = totalLY ? getMetricData(totalLY, groupedLY) : null;
            const labelsMain = SHORT_MONTHS;

            const metricLabels = {
                'total': 'Producci√≥n Total (‚Ç¨)',
                'hab': 'Prod. Habitaci√≥n (‚Ç¨)',
                'adr': 'ADR (‚Ç¨)',
                'occ': 'Ocupaci√≥n (%)'
            };

            // 3. Forecast Data (OTB) - Select based on metric
            let otbDataForChart = null;
            if (data.otb) {
                if (chartMetric === 'total') {
                    otbDataForChart = data.otb.revenue;
                } else if (chartMetric === 'hab') {
                    // For room production, show OTB rooms converted to revenue (if needed, or just rooms)
                    otbDataForChart = data.otb.rooms;
                } else if (chartMetric === 'occ') {
                    // For occupancy, calculate from OTB rooms
                    const months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
                    otbDataForChart = months.map(m => {
                        const rms = data.otb.rooms[m] || 0;
                        const days = 30.42; // average
                        return ((rms / (HOTELS[currentHotel].rooms * days)) * 100).toFixed(1);
                    });
                }
            }

            // Check if OTB has actual data (not all zeros)
            const hasOTBData = otbDataForChart && otbDataForChart.some(v => v > 0);

            // 1. Evolution Chart (Line)
            const mainChartCanvas = document.getElementById('mainChart');
            if (window.salesChart instanceof Chart) {
                window.salesChart.destroy();
            }

            // Validate canvas exists
            if (mainChartCanvas) {
                const ctx = mainChartCanvas.getContext('2d');
                window.salesChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labelsMain,
                        datasets: [
                            {
                                label: `${metricLabels[chartMetric]} ${currentYear}`,
                                data: mainDataTY,
                                borderColor: '#2563eb', // Royal Blue
                                backgroundColor: 'rgba(37, 99, 235, 0.4)', // More solid for icons
                                tension: 0.4,
                                borderWidth: 3,
                                pointBackgroundColor: '#fff',
                                pointBorderColor: '#2563eb',
                                pointRadius: 4,
                                fill: true
                            },
                            {
                                label: `${metricLabels[chartMetric]} ${parseInt(currentYear) - 1}`,
                                data: mainDataLY,
                                borderColor: '#94a3b8', // Slate 400
                                backgroundColor: '#94a3b8', // Solid for legend/tooltip icons
                                borderDash: [5, 5],
                                tension: 0.4,
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false // No area fill for LY
                            },
                            // Only add OTB dataset if invalid data exists
                            ...(hasOTBData ? [{
                                label: `Previsi√≥n OTB ${currentYear}`,
                                data: otbDataForChart,
                                borderColor: '#f59e0b', // Amber 500
                                backgroundColor: 'rgba(245, 158, 11, 0.3)', // Solid for legend
                                borderDash: [3, 3],
                                tension: 0.4,
                                borderWidth: 2,
                                pointRadius: 3,
                                pointBackgroundColor: '#fffbeb',
                                pointBorderColor: '#f59e0b',
                                fill: true
                            }] : [])
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: '#f1f5f9' },
                                ticks: { font: { size: 10 } }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { font: { size: 11 } }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                align: 'end',
                                labels: {
                                    usePointStyle: true,
                                    boxWidth: 10,
                                    font: { size: 13, weight: '600' },
                                    color: '#475569',
                                    padding: 20
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(15, 23, 42, 0.95)',
                                titleFont: { size: 14, weight: '700' },
                                bodyFont: { size: 13 },
                                bodySpacing: 6,
                                padding: 12,
                                cornerRadius: 8,
                                displayColors: true,
                                borderColor: 'rgba(255,255,255,0.1)',
                                borderWidth: 1,
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            const value = context.parsed.y;
                                            const formattedValue = new Intl.NumberFormat('es-ES', {
                                                style: chartMetric === 'adr' || chartMetric.includes('total') || chartMetric === 'hab' ? 'currency' : 'decimal',
                                                currency: 'EUR',
                                                maximumFractionDigits: 0
                                            }).format(value);
                                            label += formattedValue + (chartMetric === 'occ' ? ' %' : '');
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                // 2. Mix Chart (Doughnut)
                const mixData = [], mixLabels = [], mixIds = [];
                const otbData = data.otb || { revenue: new Array(12).fill(0), rooms: new Array(12).fill(0) };

                // Calculate Projected Totals for each group
                const groupProjected = {};
                let totalHotelProjected = 0;

                Object.entries(groupedTY).forEach(([id, g]) => {
                    const gRealVal = midx === -1 ? g.revenue.reduce((a, b) => (a || 0) + (b || 0), 0) : (g.revenue[midx] || 0);

                    // OTB Matching logic
                    let otbKey = null;
                    const gName = g.name.toUpperCase();
                    if (gName.includes('HABITACI√ìN') || gName.includes('HABITACION')) otbKey = 'habitacion';
                    else if (gName.includes('DESAYUNO')) otbKey = 'desayunos';
                    else if (gName.includes('RESTAURANTE') || gName.includes('ALMUERZO') || gName.includes('CENA')) otbKey = 'restaurante';
                    else if (gName.includes('SPA')) otbKey = 'spa';
                    else if (gName.includes('VARIOS') || gName.includes('OTROS') || gName.includes('EXTRAS')) otbKey = 'varios';

                    const groupOtbArr = (otbData.breakdown && otbKey) ? otbData.breakdown[otbKey] :
                        (otbKey === 'habitacion' ? otbData.revenue : new Array(12).fill(0));

                    const gOtbVal = midx === -1 ? groupOtbArr.reduce((a, b) => (a || 0) + (b || 0), 0) : (groupOtbArr[midx] || 0);
                    const gProj = gRealVal + gOtbVal;

                    groupProjected[id] = gProj;
                    totalHotelProjected += gProj;
                });

                Object.entries(groupedTY).forEach(([id, g]) => {
                    const val = groupProjected[id];
                    if (val > 0) {
                        const pct = totalHotelProjected > 0 ? ((val / totalHotelProjected) * 100).toFixed(1) : 0;
                        mixData.push(val);
                        mixLabels.push(`${g.name.split('. ')[1] || g.name} (${pct}%)`);
                        mixIds.push(id);
                    }
                });

                if (charts.mix) charts.mix.destroy();
                charts.mix = new Chart(document.getElementById('mixChart'), {
                    type: 'doughnut',
                    data: { labels: mixLabels, datasets: [{ data: mixData, backgroundColor: ['#4f46e5', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16', '#64748b', '#1e293b'] }] },
                    options: {
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'right' },
                            title: { display: true, text: 'Click para ver detalle', font: { size: 10 } },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const value = context.raw;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        const label = context.label || '';
                                        const valFmt = new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR', maximumFractionDigits: 0 }).format(value);
                                        return ` ${label}: ${valFmt} (${percentage}%)`;
                                    }
                                }
                            }
                        },
                        onClick: (e, items) => {
                            if (items.length > 0) {
                                const idx = items[0].index;
                                const gid = mixIds[idx];
                                showDrillDown(gid, groupedTY, midx);
                            }
                        },
                        onHover: (event, chartElement) => {
                            event.native.target.style.cursor = chartElement[0] ? 'pointer' : 'default';
                        }
                    }
                });

                // 3. Pace Chart (Bar)
                const labelsPace = midx === -1 ? SHORT_MONTHS : [MONTH_ORDER[midx]];
                const tyPace = [], lyPace = [];

                const months = midx === -1 ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [midx];
                months.forEach(m => {
                    const pTY = (totalTY.pax && totalTY.pax[m]) || 0;
                    // PARKING is now inside OFICINAS, so we don't sum it separately here or we depend on where it ended up. 
                    // Previous logic summed SPA + PARKING + MINIBAR + VARIOS.
                    // Since PARKING is now OFICINAS, we could include OFICINAS if that was the intent, but usually Offices don't correlate to Pax.
                    // Let's safe guard the access.
                    const valSpa = (groupedTY.SPA && groupedTY.SPA.revenue && groupedTY.SPA.revenue[m]) || 0;
                    const valMinibar = (groupedTY.MINIBAR && groupedTY.MINIBAR.revenue && groupedTY.MINIBAR.revenue[m]) || 0;
                    const valVarios = (groupedTY.VARIOS && groupedTY.VARIOS.revenue && groupedTY.VARIOS.revenue[m]) || 0;
                    // removed PARKING as it is not a top level key anymore

                    const cTY = valSpa + valMinibar + valVarios;
                    tyPace.push(pTY > 0 ? (cTY / pTY).toFixed(2) : 0);

                    if (totalLY && totalLY.pax) {
                        const pLY = (totalLY.pax[m]) || 0;
                        const valSpaLY = (groupedLY && groupedLY.SPA && groupedLY.SPA.revenue && groupedLY.SPA.revenue[m]) || 0;
                        const valMinibarLY = (groupedLY && groupedLY.MINIBAR && groupedLY.MINIBAR.revenue && groupedLY.MINIBAR.revenue[m]) || 0;
                        const valVariosLY = (groupedLY && groupedLY.VARIOS && groupedLY.VARIOS.revenue && groupedLY.VARIOS.revenue[m]) || 0;

                        const cLY = valSpaLY + valMinibarLY + valVariosLY;
                        lyPace.push(pLY > 0 ? (cLY / pLY).toFixed(2) : 0);
                    } else {
                        lyPace.push(0);
                    }
                });

                if (charts.pace) charts.pace.destroy();
                charts.pace = new Chart(document.getElementById('paceChart'), {
                    type: 'bar',
                    data: {
                        labels: labelsPace,
                        datasets: [
                            { label: 'Current (‚Ç¨/pax)', data: tyPace, backgroundColor: '#4f46e5' },
                            { label: 'LY (‚Ç¨/pax)', data: lyPace, backgroundColor: '#cbd5e1' }
                        ]
                    },
                    options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                });
            }

            function showDrillDown(gid, grouped, midx) {
                const group = grouped[gid];
                if (!group || !group.details.length) return;

                document.getElementById('subMixModal').style.display = 'flex';
                document.getElementById('subMixTitle').innerText = `Desglose: ${group.name.split('. ')[1]}`;

                const labels = [], data = [];
                const totalGroupVal = group.details.reduce((acc, s) => acc + (midx === -1 ? s.revenue.reduce((a, b) => (a || 0) + (b || 0), 0) : (s.revenue[midx] || 0)), 0);

                group.details.sort((a, b) => {
                    const getV = (arr) => midx === -1 ? arr.reduce((x, y) => (x || 0) + (y || 0), 0) : (arr[midx] || 0);
                    return getV(b.revenue) - getV(a.revenue);
                }).forEach(s => {
                    const val = midx === -1 ? s.revenue.reduce((a, b) => (a || 0) + (b || 0), 0) : (s.revenue[midx] || 0);
                    if (val > 0) {
                        const perc = totalGroupVal > 0 ? ((val / totalGroupVal) * 100).toFixed(1) : 0;
                        labels.push(`${s.name} (${perc}%)`);
                        data.push(val);
                    }
                });

                if (charts.subMix) charts.subMix.destroy();
                charts.subMix = new Chart(document.getElementById('subMixChart'), {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data,
                            backgroundColor: ['#4f46e5', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16', '#64748b', '#1e293b']
                        }]
                    },
                    options: {
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'bottom', labels: { boxWidth: 12, font: { size: 10 } } }
                        }
                    }
                });
            }
        };
    </script>
</body>

</html>
```